# Weak supported encryption algorithms on DCs 
üóìÔ∏è Published: 2025-05-05

---

## üîê Introduction ‚Äì Kerberos Encryption Algorithms on Domain Controllers

In Active Directory environments, Kerberos authentication is the default and most secure protocol used for identity verification. When a user or service authenticates, Kerberos tickets are issued by the Key Distribution Center (KDC), which is implemented on Domain Controllers (DCs).

Each Kerberos ticket is encrypted using one or more supported algorithms. These encryption types determine how credentials and session keys are protected in transit. Over time, encryption standards have evolved ‚Äî from DES (Data Encryption Standard) and RC4 to AES (Advanced Encryption Standard).

The following encryption types are commonly found on Windows DCs:

| Encryption Type           | Hex Value       | Status                        |
| ------------------------- | --------------- | ----------------------------- |
| DES-CBC-CRC / DES-CBC-MD5 | `0x1` / `0x2`   | Deprecated & insecure ‚ùå       |
| RC4-HMAC                  | `0x4`           | Weak (legacy support) ‚ö†Ô∏è      |
| AES128-CTS-HMAC-SHA1-96   | `0x8`           | Strong ‚úÖ                      |
| AES256-CTS-HMAC-SHA1-96   | `0x10`          | Strong ‚úÖ                      |
| AES\*-HMAC-SHA2 (256/384) | `0x11` / `0x12` | Very strong (newer systems) ‚úÖ |
| Future encryption types   | `0x20`          | Reserved for future use       |

While older encryption types (DES, RC4) were once used for compatibility with legacy systems, they are now considered cryptographically broken or weak. Microsoft recommends disabling DES and RC4, and ensuring DCs support and issue only AES-based tickets.

Auditing the encryption algorithms used and supported on your domain controllers is a critical step in securing your identity infrastructure.

### üìé Understanding msDS-SupportedEncryptionTypes

The msDS-SupportedEncryptionTypes attribute is a bitmask stored on computer objects in Active Directory. It defines which Kerberos encryption types a computer ‚Äî including Domain Controllers (DCs) ‚Äî is allowed to use for issuing and accepting Kerberos tickets.

When this attribute is not set, the system falls back to default behavior, typically allowing RC4 for backward compatibility.
When explicitly configured, the attribute value is calculated as a sum of hexadecimal flags corresponding to the desired encryption algorithms.

For example:

0x18 = 0x8 (AES128) + 0x10 (AES256) ‚Üí AES only

0x1C = AES128 + AES256 + Future types

0x1F = AES + RC4 + DES ‚Äî ‚ùå insecure, should be avoided

This setting can be manually applied per computer, but for Domain Controllers, Microsoft strongly recommends configuring it via Group Policy, using:

Computer Configuration > Policies > Windows Settings > Security Settings > Local Policies > Security Options >
‚ÄúNetwork security: Configure encryption types allowed for Kerberos‚Äù

This approach ensures consistent and centralized control over Kerberos encryption policies across your domain.

---

## üßæ Phase 1 ‚Äì Reporting on Kerberos Encryption Configuration of Domain Controllers

The first step in securing Kerberos encryption across an Active Directory forest is to identify what encryption algorithms are currently enabled on each Domain Controller. This is done by querying the msDS-SupportedEncryptionTypes attribute for all DCs across all domains in the forest.

The PowerShell script below performs this task by:

- Iterating over all domains in the forest
- Querying each Domain Controller‚Äôs computer object
- Decoding the bitmask of supported encryption algorithms using a predefined map
- Flagging each DC with a vulnerability level based on known risks:
- Level 2 ‚Üí DES algorithms are enabled (DES-CBC-CRC, DES-CBC-MD5)
- Level 3 ‚Üí AES is not supported (no AES128 or AES256)
- Level 4 ‚Üí RC4 is enabled (RC4-HMAC)
- OK ‚Üí Only AES is enabled

This gives administrators a clear view of which DCs are misconfigured and potentially exposing the environment to cryptographic weaknesses.

Below is the script used to perform this forest-wide assessment:

* ‚úÖ Prerequisites
Before running the Kerberos encryption audit script across your forest, make sure the following prerequisites are met:

üîß PowerShell Environment
Windows PowerShell 5.1 or PowerShell 7+

Run from a domain-joined machine (management server, workstation, or Domain Controller)

* üß∞ Required Modules
Active Directory PowerShell module

* üîê Permissions
The script must be executed by an account that has read access to all domains and DC computer objects

Typically: a Domain Admin, Enterprise Admin, or a delegated admin account with at least read access to msDS-SupportedEncryptionTypes

* üåê Network Requirements
The machine running the script must be able to resolve and connect to all Domain Controllers via:

DNS

LDAP / RPC (default ports: 389, 135)

Firewall rules must allow LDAP/LDAPs queries and remote AD object resolution across domains


```powershell
# Define encryption algorithm bitmask values
$EncryptionTypesMap = @{
    "DES-CBC-CRC"              = 0x1
    "DES-CBC-MD5"              = 0x2
    "RC4-HMAC"                 = 0x4
    "AES128-CTS-HMAC-SHA1-96" = 0x8
    "AES256-CTS-HMAC-SHA1-96" = 0x10
    "Future encryption types" = 0x20
}

# Initialize result array
$results = @()

# Get all domains in the forest
$forest = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()
$domains = $forest.Domains

foreach ($domain in $domains) {
    Write-Host "`nüîç Domain: $($domain.Name)" -ForegroundColor Cyan

    # Connect to domain context
    $domainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Domain', $domain.Name)
    $domainDCs = [System.DirectoryServices.ActiveDirectory.DomainController]::FindAll($domainContext)

    foreach ($dc in $domainDCs) {
        $dcName = $dc.Name.Split(".")[0]  # NetBIOS name
        try {
            # Get the msDS-SupportedEncryptionTypes attribute
            $adComputer = Get-ADComputer -Server $domain.Name -Identity $dcName -Properties msDS-SupportedEncryptionTypes
            $encTypes = $adComputer.'msDS-SupportedEncryptionTypes'

            if (-not $encTypes) {
                $enabledAlgos = "Not Set (defaults to RC4)"
                $level = "Level 4 (RC4 fallback)"
            } else {
                $enabledAlgosList = (
                    $EncryptionTypesMap.GetEnumerator() | Where-Object {
                        ($encTypes -band $_.Value)
                    } | ForEach-Object {
                        $_.Key
                    }
                )
                $enabledAlgos = $enabledAlgosList -join ', '

                # Determine vulnerability level
                if ($enabledAlgosList -contains "DES-CBC-CRC" -or $enabledAlgosList -contains "DES-CBC-MD5") {
                    $level = "Level 2 (DES enabled)"
                } elseif (-not ($enabledAlgosList -contains "AES128-CTS-HMAC-SHA1-96" -or $enabledAlgosList -contains "AES256-CTS-HMAC-SHA1-96")) {
                    $level = "Level 3 (no AES)"
                } elseif ($enabledAlgosList -contains "RC4-HMAC") {
                    $level = "Level 4 (RC4 enabled)"
                } else {
                    $level = "OK"
                }
            }

            # Add to results
            $results += [PSCustomObject]@{
                Domain                   = $domain.Name
                DCName                   = $dcName
                FQDN                     = $dc.Name
                SupportedEncryptionTypes = if ($encTypes) { "0x{0:X}" -f $encTypes } else { "Not Set" }
                EnabledAlgorithms        = $enabledAlgos
                VulnerabilityLevel       = $level
            }
        } catch {
            Write-Warning "‚ùå Error for $dcName in $($domain.Name): $_"
        }
    }
}

# Output results
$results | Format-Table -AutoSize
# Optional: export to CSV
# $results | Export-Csv "Kerberos_Encryption_Forest_Audit.csv" -NoTypeInformation

```

---

## ‚öôÔ∏è Detection Logic (KQL Query)

```sql
IdentityDirectoryEvents
| where ActionType == "Account Password Never Expires changed"
| extend AdditionalInfo = parse_json(AdditionalFields)
| extend OriginalValue = AdditionalInfo.['FROM Account Password Never Expires']
| extend NewValue = AdditionalInfo.['TO Account Password Never Expires']
| where NewValue == true
| project
     Timestamp,
     TargetAccountUpn,
     AccountDomain,
     OriginalValue,
     NewValue,
     ReportId,
     DeviceName
```



---

## üõ†Ô∏è Recommended Actions

### üîé 1. Audit all accounts with non-expiring passwords  
Run the following PowerShell command to list accounts where the **"Password Never Expires"** setting is enabled:  

```powershell
Get-ADUser -Filter * | Where-Object { $_.PasswordNeverExpires }
```

### üö´ 2. Enforce password expiration policies  
- **Active Directory (on-premises)**: Configure Group Policy (GPO) to set a **maximum password age**.  
- **Azure AD**: Use **Conditional Access** policies to enforce periodic password changes.

### üîí 3. Use Multi-Factor Authentication (MFA) and strong password policies  
- Require **MFA** for high-privilege accounts.  
- Enforce **password length and complexity rules** to reduce brute force risks.  

---

## üíé References

- [Original detection rule](https://github.com/Bert-JanP/Hunting-Queries-Detection-Rules/blob/main/Defender%20For%20Identity/AccountWithPasswordNeverExpiresEnabled.md)  
- [Microsoft Security Best Practices](https://learn.microsoft.com/en-us/security/)  
- [Azure AD Conditional Access Policies](https://learn.microsoft.com/en-us/azure/active-directory/conditional-access/overview)  