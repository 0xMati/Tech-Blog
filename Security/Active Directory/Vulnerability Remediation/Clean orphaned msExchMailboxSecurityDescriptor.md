Clean orphaned msExchMailboxSecurityDescriptor
üóìÔ∏è Published: 2025-05-06

## üß± 1. Introduction
In large Active Directory environments with Exchange, it‚Äôs common to find **orphaned permissions**‚ÄîACE entries in mailbox security descriptors that reference SIDs for accounts that no longer exist. These leftover ACEs clutter your ACLs and can generate false positives in security audits or tools like OraDAD.

In this article, we‚Äôll cover:
1. Why orphaned ACEs occur in `msExchMailboxSecurityDescriptor`
2. How to test resolution on a single mailbox
3. A reusable PowerShell script to clean orphaned ACEs across an OU, complete with interactive prompts and optional CSV export

---

## üß™ 3. Single-mailbox test
Before wide-scale cleanup, verify the approach on one mailbox (e.g., user **Pepito**):

```powershell
Import-Module ActiveDirectory

# 1. Target your single user
$user = Get-ADUser -Identity 'Pepito' -Properties msExchMailboxSecurityDescriptor

# 2. Ensure the attribute is present and of the right type
if (-not ($user.msExchMailboxSecurityDescriptor -is [System.DirectoryServices.ActiveDirectorySecurity])) {
    Write-Error "No valid msExchMailboxSecurityDescriptor found for Pepito."
    return
}
$sd = $user.msExchMailboxSecurityDescriptor

# 3. Extract & resolve each ACE‚Äôs SID
$results = $sd.GetAccessRules($true, $true, [System.Security.Principal.SecurityIdentifier]) |
    ForEach-Object {
        $sidValue = $_.IdentityReference.Value
        try {
            $account = $_.IdentityReference.Translate([System.Security.Principal.NTAccount]).Value
            $status  = 'Resolved'
        }
        catch {
            $account = ''
            $status  = 'Unknown'
        }
        [PSCustomObject]@{
            User    = $user.SamAccountName
            SID     = $sidValue
            Status  = $status
            Account = $account
        }
    }

# 4. Display neatly
$results | Format-Table -AutoSize
```

You should see which SIDs resolve and identify any orphans before proceeding.

![](assets/Clean%20orphaned%20msExchMailboxSecurityDescriptor/2025-07-01-12-13-42.png)

---

## ‚öôÔ∏è 4. OU-wide cleanup script
Use this interactive PowerShell script to target an entire OU, choose between **TEST** (dry-run) or **DELETE** (live) modes, and optionally export results:

```powershell
# Clear console
cls
Import-Module ActiveDirectory

# 1. Prompt for mode
Write-Host "########################################################################################" -ForegroundColor Green
Write-Host "Do you want to run in TEST mode or DELETE mode? Type TEST or DELETE" -ForegroundColor Green
Write-Host "########################################################################################" -ForegroundColor Green
$mode = Read-Host
switch ($mode.Trim().ToUpper()) {
    'TEST'   { $DryRun = $true;  Write-Host "Running in TEST (dry-run) mode.`n" -ForegroundColor Yellow }
    'DELETE' { $DryRun = $false; Write-Host "Running in DELETE (live) mode.`n"   -ForegroundColor Red    }
    default  { Write-Error "Invalid mode. Please type TEST or DELETE"; exit }
}

# 2. Prompt for OU to analyze
Write-Host "########################################################################################" -ForegroundColor Green
Write-Host "Enter the distinguished name of the OU to analyze (e.g. OU=Users,OU=PRD,DC=ext,DC=local)" -ForegroundColor Green
Write-Host "########################################################################################" -ForegroundColor Green
$ou = Read-Host
if (-not (Get-ADOrganizationalUnit -Identity $ou -ErrorAction SilentlyContinue)) {
    Write-Error "The OU '$ou' could not be found. Exiting."; exit
}
Write-Host "Targeting OU: $ou`n" -ForegroundColor Cyan

# 3. Prompt for CSV export
Write-Host "########################################################################################" -ForegroundColor Green
Write-Host "Do you want a CSV export of the result? Type YES or NO" -ForegroundColor Green
Write-Host "########################################################################################" -ForegroundColor Green
$exportCsvAnswer = Read-Host
$exportCsv       = $exportCsvAnswer.Trim().ToUpper() -eq 'YES'
if ($exportCsv) {
    Write-Host "########################################################################################" -ForegroundColor Green
    Write-Host "Enter full path for CSV export (default: C:\temp\orphan_cleanup.csv)" -ForegroundColor Green
    Write-Host "########################################################################################" -ForegroundColor Green
    $exportPath = Read-Host
    if ([string]::IsNullOrWhiteSpace($exportPath)) {
        $exportPath = 'C:\temp\orphan_cleanup.csv'
        Write-Host "Using default: $exportPath" -ForegroundColor Cyan
    }
    Write-Host "Results will be exported to $exportPath`n" -ForegroundColor Cyan
}

# 4. Countdown
for ($i = 5; $i -ge 1; $i--) {
    Write-Host "Launching script in $i..." -ForegroundColor Cyan
    Start-Sleep -Seconds 1
}
Write-Host "GO!`n" -ForegroundColor Green

# 5. Prepare results
$exportResults = @()

# 6. Iterate and clean
$users = Get-ADUser -Filter * -SearchBase $ou -Properties msExchMailboxSecurityDescriptor
foreach ($user in $users) {
    $name = $user.SamAccountName
    Write-Host "`n=== Processing $name ===" -ForegroundColor Cyan

    $sd = $user.msExchMailboxSecurityDescriptor
    if (-not $sd -or -not ($sd -is [System.DirectoryServices.ActiveDirectorySecurity])) {
        Write-Host "  No mailbox SD, skipping" -ForegroundColor DarkGray
        continue
    }

    $aces = $sd.GetAccessRules($true, $true, [System.Security.Principal.SecurityIdentifier])
    Write-Host "  Found $($aces.Count) ACE(s)" -ForegroundColor Yellow

    $orphans = $aces | Where-Object {
        try { $_.IdentityReference.Translate([System.Security.Principal.NTAccount]) | Out-Null; $false }
        catch { $true }
    }
    if ($orphans.Count -eq 0) { Write-Host "  No orphan ACEs" -ForegroundColor Green; continue }

    Write-Host "  Removing $($orphans.Count) orphan ACE(s):" -ForegroundColor Magenta
    foreach ($r in $orphans) {
        $sid = $r.IdentityReference.Value
        if ($DryRun) { Write-Host "    [TEST] Would remove $sid" -ForegroundColor Magenta; $action='WouldRemove' }
        else           { Write-Host "    Removing $sid" -ForegroundColor Magenta; $sd.RemoveAccessRule($r); $action='Removed' }
        $exportResults += [pscustomobject]@{ User=$name; SID=$sid; Action=$action; Time=(Get-Date -Format s) }
    }

    if (-not $DryRun) {
        $bin = $sd.GetSecurityDescriptorBinaryForm()
        Set-ADUser -Identity $name -Replace @{ msExchMailboxSecurityDescriptor = $bin }
        Write-Host "  >> Updated $name" -ForegroundColor Green
    }
}

# 7. Export CSV if requested
if ($exportCsv) {
    $exportResults | Export-Csv -Path $exportPath -NoTypeInformation -Force
    Write-Host "`nResults exported to $exportPath" -ForegroundColor Cyan
}

Write-Host "`nAll users processed." -ForegroundColor White
```

- Test mode:

![](assets/Clean%20orphaned%20msExchMailboxSecurityDescriptor/2025-07-01-12-17-10.png)

![](assets/Clean%20orphaned%20msExchMailboxSecurityDescriptor/2025-07-01-12-17-34.png)

- Delete mode:

![](assets/Clean%20orphaned%20msExchMailboxSecurityDescriptor/2025-07-01-12-18-43.png)

![](assets/Clean%20orphaned%20msExchMailboxSecurityDescriptor/2025-07-01-12-18-56.png)

![](assets/Clean%20orphaned%20msExchMailboxSecurityDescriptor/2025-07-01-12-19-10.png)

## ‚û°Ô∏è 5. Next steps

* Run in TEST mode first to review orphaned SIDs.
* Switch to DELETE to commit actual cleanup.


